**File Purpose**: This guide helps LLM agents build simple Next.js 15 applications using the App Router.

## Next.js 15 Coding Guide

### 1. Project Setup

Start new Next.js projects with the App Router.

### 2. Project Structure (`src/app`)

The `src/app` directory is the core of the App Router.

*   **`src/app/layout.tsx`**: Root layout, wraps all pages. Essential for `<html>`, `<body>`, global CSS.
*   **`src/app/page.tsx`**: Root page of your application (`/`).
*   **`src/app/[folder]/page.tsx`**: Defines routes based on folder names (e.g., `src/app/about/page.tsx` for `/about`).
*   **`src/app/[folder]/layout.tsx`**: Defines a nested layout for routes within that folder.
*   **`src/app/api/[route]/route.ts`**: Defines API Route Handlers.
*   **`src/app/globals.css`**: Global styles.

### 3. Pages and Layouts

Every route segment in `src/app` requires a `page.tsx` or `route.ts` file to be publicly accessible.

#### Root Layout (`src/app/layout.tsx`)

This is required and wraps all pages.

```typescript
// src/app/layout.tsx
import type { Metadata } from 'next';
import { Inter } from 'next/font/google';
import './globals.css';

const inter = Inter({ subsets: ['latin'] });

export const metadata: Metadata = {
  title: 'My Next.js App',
  description: 'Generated by create-next-app',
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={inter.className}>{children}</body>
    </html>
  );
}
```
*   **`children` prop**: Automatically populated with the current page's content.
*   **`metadata` export**: Defines page metadata (title, description, etc.).

#### Root Page (`src/app/page.tsx`)

This is your homepage (`/`).

```typescript
// src/app/page.tsx
export default function HomePage() {
  return (
    <main className="flex min-h-screen flex-col items-center justify-between p-24">
      <h1 className="text-4xl font-bold">Welcome to Next.js 15!</h1>
      <p className="mt-4 text-lg">Start building your application.</p>
      {/* Example link to another page */}
      <a href="/dashboard" className="text-blue-500 hover:underline mt-8">Go to Dashboard</a>
    </main>
  );
}
```

#### Nested Pages (`src/app/dashboard/page.tsx`)

Create sub-pages by adding folders. For `example.com/dashboard`:

```typescript
// src/app/dashboard/page.tsx
export default function DashboardPage() {
  return (
    <div className="p-8">
      <h2 className="text-3xl font-semibold">Dashboard</h2>
      <p className="mt-4">This is your dashboard page.</p>
    </div>
  );
}
```

#### Dynamic Routes (`src/app/blog/[slug]/page.tsx`)

Handles routes like `/blog/my-post` or `/blog/another-article`.

```typescript
// src/app/blog/[slug]/page.tsx
interface BlogPageProps {
  params: { slug: string };
}

export default function BlogPage({ params }: BlogPageProps) {
  return (
    <div className="p-8">
      <h2 className="text-3xl font-semibold">Blog Post: {params.slug}</h2>
      <p className="mt-4">Content for {params.slug} goes here.</p>
    </div>
  );
}
```
*   **`params`**: Contains dynamic route segments (e.g., `slug`).

### 4. Server Components vs. Client Components

Next.js App Router defaults to **Server Components**.

*   **Server Components (Default):**
    *   Render on the server.
    *   Can directly fetch data (e.g., `await fetch()`) or call server-side logic.
    *   No `useState`, `useEffect`, or browser APIs.
    *   Ideal for static content, data fetching, and performance.
*   **Client Components (`'use client'`):**
    *   Render on the client (browser).
    *   Can use `useState`, `useEffect`, event handlers, browser APIs.
    *   Hydrated on the client for interactivity.
    *   Requires the `'use client'` directive at the top of the file.

#### Example Server Component (`src/components/Greeting.tsx`)

```typescript
// src/components/Greeting.tsx
// This is a Server Component by default
export default async function Greeting() {
  // Simulate fetching data (e.g., user name from a database or API)
  const username = await new Promise(resolve => setTimeout(() => resolve('Alice'), 1000));
  return (
    <p className="text-lg">Hello, {username}! This content was rendered on the server.</p>
  );
}
```

#### Example Client Component (`src/components/Counter.tsx`)

```typescript
// src/components/Counter.tsx
'use client'; // This directive makes it a Client Component
import { useState } from 'react';

export default function Counter() {
  const [count, setCount] = useState(0);

  return (
    <button
      onClick={() => setCount(count + 1)}
      className="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded"
    >
      Count: {count}
    </button>
  );
}
```
*   **Usage:** Embed Client Components within Server Components as needed.
*   **Composition Note:** It's important to understand that Server Components can render Client Components, and crucially, Client Components can accept and render Server Components as `children`. This allows you to "punch a hole" through a client boundary to include server-rendered content deeper in your tree, optimizing initial load performance.

### 5. Data Fetching

#### Server Components (Recommended for initial data)

> **Breaking change** Starting with **Next 15**, _every_ `fetch()` call, **GET** Route Handler, and client navigation is treated as `cache: 'no-store'` unless you explicitly opt-in to caching. [Next.js](https://nextjs.org/blog/next-15?utm_source=chatgpt.com)

##### 5.1 Choose the right caching mode

| Your intent                                        | How to opt-in                                                                 | Resulting behaviour                        |
| -------------------------------------------------- | ----------------------------------------------------------------------------- | ------------------------------------------ |
| **Fully dynamic** – always refetch                 | _Do nothing_ (default)                                                        | `no-store` – data fetched on every request |
| **Static, never revalidate**                       | `cache: 'force-cache'` **or**  <br>`export const dynamic = 'force-static';` ¹ | Response cached until the next build       |
| **Static + ISR** (Incremental Static Regeneration) | `next: { revalidate: 60 }` (seconds)                                          | Cache auto-refreshes after timeout         |
| **Tag-based purge** (Edge **or** Node)             | `next: { tags: ['products'] }` + `revalidateTag('products')`                  | Granular purge without a full rebuild      |

> ¹ `dynamic: 'force-static'` is a **file-level export** at the top of a page or Route Handler.

```typescript
// app/products/page.tsx — React Server Component
export const dynamic = 'force-static';   // opt-in to full static caching (remove if live)

// Domain types
interface Product {
  id: number;
  name: string;
  price: number;
}

/** Static roster (cached until rebuild or revalidate) */
async function getProductsStatic(): Promise<Product[]> {
  const res = await fetch('https://api.example.com/products', {
    cache: 'force-cache',          // ✅ explicit opt-in
  });
  if (!res.ok) throw new Error('Failed to fetch products'); // ISR will serve last good cache
  return res.json<Product[]>();    // keep TypeScript safety
}

/** Live roster (never cached) */
async function getProductsLive(): Promise<Product[]> {
  const res = await fetch('https://api.example.com/products'); // ⬅ default no-store
  if (!res.ok) throw new Error('Failed to fetch products');
  return res.json<Product[]>();
}

export default async function ProductsPage() {
  // during dev we prefer live data; in prod we prefer static
  const products =
    process.env.NODE_ENV === 'development'
      ? await getProductsLive()
      : await getProductsStatic();

  return (
    <div className="p-8">
      <h2 className="text-3xl font-semibold">Products</h2>
      <ul className="mt-4 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
        {products.map((p) => (
          <li key={p.id} className="border p-4 rounded-lg">
            <h3 className="text-xl font-bold">{p.name}</h3>
            <p>${p.price.toFixed(2)}</p>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

##### 5.2 Field notes & gotchas

- **Internal data? Skip the network.** When the source lives inside your app (e.g., DB via Prisma), call that repository function directly from the Server Component or a shared util. Reserve `fetch()` for _external_ APIs or when you need Next.js cache keys.
- **Route Handlers** now inherit the same default. Wrap expensive logic in `cache()` or export `dynamic = 'force-static'` if you want a GET handler to act like a CDN-friendly endpoint.
- **Client Components** behave as in the browser—`fetch()` inside `useEffect` is still uncached. Prefer SWR / React Query for on-mount calls.
- **Dev vs prod**: In `next dev`, HMR resets the cache; you’ll often see fresh data even when `force-cache` is set—don’t mistake this for a production bug.    
- **Version control**: Pin `next@15` in `package.json` and run your full test suite after any minor update; caching defaults occasionally change between RC and stable.

#### Client Components (For interactive data, e.g., search, pagination)

Use `useEffect` with `fetch` or a dedicated data fetching library (e.g., SWR, React Query).

```typescript
// src/components/ClientProductList.tsx
'use client';
import { useState, useEffect } from 'react';

interface Product { /* ... same as above */ }

export default function ClientProductList() {
  const [products, setProducts] = useState<Product[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    async function fetchProducts() {
      try {
        const res = await fetch('/api/products'); // Fetch from an internal API Route for client-side reads/interactions
        if (!res.ok) throw new Error('Failed to fetch products');
        const data: Product[] = await res.json();
        setProducts(data);
      } catch (err: any) {
        setError(err.message);
      } finally {
        setLoading(false);
      }
    }
    fetchProducts();
  }, []);

  if (loading) return <p>Loading products...</p>;
  if (error) return <p className="text-red-500">Error: {error}</p>;

  // Render products (similar to Server Component example)
  return (
    <ul className="mt-4 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
      {products.map(product => (
        <li key={product.id} className="border p-4 rounded-lg">
          <h3 className="text-xl font-bold">{product.name}</h3>
          <p>${product.price.toFixed(2)}</p>
        </li>
      ))}
    </ul>
  );
}
```
*   For data *mutations* initiated from Client Components (e.g., form submissions), Server Actions (`'use server'`) are generally preferred over fetching to an internal API Route Handler, as they offer closer integration with React's form handling and data revalidation.

### 6. Navigation

Use the `next/link` component for client-side navigation.

```typescript
// src/app/page.tsx (or any component)
import Link from 'next/link';

export default function HomePage() {
  return (
    <main>
      <h1>Home</h1>
      <nav>
        <Link href="/about" className="text-blue-500 hover:underline mr-4">About Us</Link>
        <Link href="/dashboard" className="text-blue-500 hover:underline">Dashboard</Link>
      </nav>
    </main>
  );
}
```
*   **`Link`**: Prefetches pages for faster transitions.
*   **`useRouter` (Client Components only):** For programmatic navigation.
    ```typescript
    'use client';
    import { useRouter } from 'next/navigation';
    export default function MyButton() {
      const router = useRouter();
      return <button onClick={() => router.push('/settings')}>Go to Settings</button>;
    }
    ```

### 7. Styling

*   **Global CSS:** `src/app/globals.css` imported in `src/app/layout.tsx`.
*   **Tailwind CSS:** (If chosen during setup) Use utility classes directly in JSX.
*   **CSS Modules:** For component-specific styles (`ComponentName.module.css`).

### 8. API Routes (Route Handlers)

Create backend API endpoints within your Next.js project.
Files in `src/app/api/[folder]/route.ts` handle HTTP methods (GET, POST, PUT, DELETE).

```typescript
// src/app/api/products/route.ts
import { NextResponse } from 'next/server';

const products = [
  { id: 1, name: 'Laptop', price: 1200 },
  { id: 2, name: 'Mouse', price: 25 },
];

export async function GET(request: Request) {
  const { searchParams } = new URL(request.url);
  const search = searchParams.get('search');

  let filteredProducts = products;
  if (search) {
    filteredProducts = products.filter(p =>
      p.name.toLowerCase().includes(search.toLowerCase())
    );
  }

  return NextResponse.json(filteredProducts);
}

export async function POST(request: Request) {
  const newProduct = await request.json();
  // In a real app, you'd save newProduct to a database
  products.push({ ...newProduct, id: products.length + 1 }); // Simple example
  return NextResponse.json({ message: 'Product added', product: newProduct }, { status: 201 });
}
```
*   **`NextResponse`**: Utility for sending JSON responses.
*   **Dynamic API Routes:** `src/app/api/products/[id]/route.ts` for `/api/products/1`.

### 9. Building and Deployment

*   **Build:** `pnpm build` creates an optimized production build.
*   **Start:** `pnpm start` runs the production build.
*   **Deployment:** Vercel is the recommended platform and offers seamless deployment for Next.js apps. Most standard Node.js hosting environments will also work.

### 10. What's New in Next.js 15:

- @next/codemod CLI: Easily upgrade to the latest Next.js and React versions.
- Async Request APIs (Breaking): Incremental step towards a simplified rendering and caching model.
- Caching Semantics (Breaking): fetch requests, GET Route Handlers, and client navigations are no longer cached by default.
- React 19 Support: Support for React 19, React Compiler (Experimental), and hydration error improvements.
- Turbopack Dev (Stable): Performance and stability improvements.
- Static Indicator: New visual indicator shows static routes during development.
- instrumentation.js API (Stable): New API for server lifecycle observability.
- Enhanced Forms (next/form): Enhance HTML forms with client-side navigation.
- next.config: TypeScript support for next.config.ts.
- Self-hosting Improvements: More control over Cache-Control headers.
- Server Actions Security: Unguessable endpoints and removal of unused actions.
- Bundling External Packages (Stable): New config options for App and Pages Router.
- ESLint 9 Support: Added support for ESLint 9.
- Development and Build Performance: Improved build times and Faster Fast Refresh.